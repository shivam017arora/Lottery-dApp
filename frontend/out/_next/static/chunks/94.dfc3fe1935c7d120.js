"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[94],{86094:function(f,b,a){a.r(b),a.d(b,{OpenloginAdapter:function(){return n},getOpenloginDefaultOptions:function(){return k}});var g=a(3388),c=a(41436),h=a(4942),d=a(72378),i=a.n(d),e=a(2043),j=a.n(e);const k=(a,b)=>({adapterSettings:{network:g.dr.MAINNET,clientId:"",uxMode:g.$e.POPUP},chainConfig:a?(0,c.h2)(a,b):void 0,loginSettings:{relogin:!0}});function l(c,d){var a=Object.keys(c);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(c);d&&(b=b.filter(function(a){return Object.getOwnPropertyDescriptor(c,a).enumerable})),a.push.apply(a,b)}return a}function m(c){for(var a=1;a<arguments.length;a++){var b=null!=arguments[a]?arguments[a]:{};a%2?l(Object(b),!0).forEach(function(a){(0,h.Z)(c,a,b[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(c,Object.getOwnPropertyDescriptors(b)):l(Object(b)).forEach(function(a){Object.defineProperty(c,a,Object.getOwnPropertyDescriptor(b,a))})}return c}class n extends c.J5{constructor(a){var d,e,f,i;super(),(0,h.Z)(this,"name",c.rW.OPENLOGIN),(0,h.Z)(this,"adapterNamespace",c.yk.MULTICHAIN),(0,h.Z)(this,"type",c.hN.IN_APP),(0,h.Z)(this,"openloginInstance",null),(0,h.Z)(this,"status",c.MP.NOT_READY),(0,h.Z)(this,"currentChainNamespace",c.EN.EIP155),(0,h.Z)(this,"openloginOptions",void 0),(0,h.Z)(this,"loginSettings",{}),(0,h.Z)(this,"privKeyProvider",null),j().debug("const openlogin adapter",a);const b=k(null===(d=a.chainConfig)|| void 0===d?void 0:d.chainNamespace,null===(e=a.chainConfig)|| void 0===e?void 0:e.chainId);if(this.openloginOptions=m(m({clientId:"",network:g.dr.MAINNET},b.adapterSettings),a.adapterSettings||{}),this.loginSettings=m(m({},b.loginSettings),a.loginSettings),null!==(f=a.chainConfig)&& void 0!==f&&f.chainNamespace){this.currentChainNamespace=null===(i=a.chainConfig)|| void 0===i?void 0:i.chainNamespace;const l=b.chainConfig?b.chainConfig:{};if(this.chainConfig=m(m({},l),null==a?void 0:a.chainConfig),j().debug("const openlogin chainConfig",this.chainConfig),!this.chainConfig.rpcTarget)throw c.Ty.invalidParams("rpcTarget is required in chainConfig")}}get chainConfigProxy(){return this.chainConfig?m({},this.chainConfig):null}get provider(){var a;return(null===(a=this.privKeyProvider)|| void 0===a?void 0:a.provider)||null}set provider(a){throw new Error("Not implemented")}async init(f){var a;if(super.checkInitializationRequirements(),!(null!==(a=this.openloginOptions)&& void 0!==a&&a.clientId))throw c.Ty.invalidParams("clientId is required before openlogin's initialization");if(!this.chainConfig)throw c.Ty.invalidParams("chainConfig is required before initialization");this.openloginInstance=new g.ZP(this.openloginOptions);const b=(0,g.Gv)();let d=!0;Object.keys(b).length>0&&b.result&&(d=!0),await this.openloginInstance.init(),this.status=c.MP.READY,this.emit(c.n2.READY,c.rW.OPENLOGIN);try{this.openloginInstance.privKey&&(f.autoConnect||d)&&await this.connect()}catch(e){j().error("Failed to connect with cached openlogin provider",e),this.emit("ERRORED",e)}}async connect(b){super.checkConnectionRequirements(),this.status=c.MP.CONNECTING,this.emit(c.n2.CONNECTING,m(m({},b),{},{adapter:c.rW.OPENLOGIN}));try{return await this.connectWithProvider(b),this.provider}catch(a){if(j().error("Failed to connect with openlogin provider",a),this.status=c.MP.READY,this.emit(c.n2.ERRORED,a),null!=a&&a.message.includes("user closed popup"))throw c.RM.popupClosed();throw c.RM.connectionError("Failed to login with openlogin")}}async disconnect(){let a=arguments.length>0&& void 0!==arguments[0]?arguments[0]:{cleanup:!1};if(this.status!==c.MP.CONNECTED)throw c.RM.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw c.Ty.notReady("openloginInstance is not ready");await this.openloginInstance.logout(),a.cleanup?(this.status=c.MP.NOT_READY,this.openloginInstance=null,this.privKeyProvider=null):this.status=c.MP.READY,this.emit(c.n2.DISCONNECTED)}async getUserInfo(){if(this.status!==c.MP.CONNECTED)throw c.RM.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw c.Ty.notReady("openloginInstance is not ready");const a=await this.openloginInstance.getUserInfo();return a}setAdapterSettings(a){if(this.status===c.MP.READY)return;const b=k();this.openloginOptions=m(m(m({},b.adapterSettings),this.openloginOptions||{}),a)}setChainConfig(a){super.setChainConfig(a),this.currentChainNamespace=a.chainNamespace}async connectWithProvider(b){if(!this.chainConfig)throw c.Ty.invalidParams("chainConfig is required before initialization");if(!this.openloginInstance)throw c.Ty.notReady("openloginInstance is not ready");if(this.currentChainNamespace===c.EN.SOLANA){const{SolanaPrivateKeyProvider:e}=await Promise.all([a.e(662),a.e(766),a.e(845),a.e(108),a.e(794),a.e(23)]).then(a.bind(a,44445));this.privKeyProvider=new e({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===c.EN.EIP155){const{EthereumPrivateKeyProvider:f}=await Promise.all([a.e(662),a.e(482),a.e(845),a.e(62),a.e(917)]).then(a.bind(a,52062));this.privKeyProvider=new f({config:{chainConfig:this.chainConfig}})}else throw new Error("Invalid chainNamespace: ".concat(this.currentChainNamespace," found while connecting to wallet"));!this.openloginInstance.privKey&&b&&await this.openloginInstance.login(i()(this.loginSettings,{loginProvider:b.loginProvider},{extraLoginOptions:{login_hint:null==b?void 0:b.login_hint}}));let d=this.openloginInstance.privKey;if(d){if(this.currentChainNamespace===c.EN.SOLANA){const{getED25519Key:g}=await Promise.all([a.e(108),a.e(418)]).then(a.bind(a,33946));d=g(d).sk.toString("hex")}await this.privKeyProvider.setupProvider(d),this.status=c.MP.CONNECTED,this.emit(c.n2.CONNECTED,{adapter:c.rW.OPENLOGIN,reconnected:!b})}}}}}])